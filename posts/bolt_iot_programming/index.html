<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Programming a Non-Programmable ESP8266 Board | Jasmeet Singh</title><meta name=keywords content="ESP8266,IOT,Boot Modes,Programming,Bolt IOT"><meta name=description content="If you are like me, you want RGB lights in everything. Be it your mouse, your keyboard, or heck even your room. Therefore, to fulfill this colorful need, I started working on a project to install the addressable WS2812B LEDs to the shelves in my room. The plan was simple: use an ESP8266-based board (specifically the Wemos D1 Mini) with WLED installed as the main controller, hook it up the LEDs and use the WLED Android App to control the LEDs."><meta name=author content="Me"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.afb1600d5eb8bfe4548af2f8a27942f3a0900a9b655e2d0df255195061f680fb.css integrity="sha256-r7FgDV64v+RUivL4onlC86CQCptlXi0N8lUZUGH2gPs=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=icon href=https://jasmeet0915.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://jasmeet0915.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://jasmeet0915.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://jasmeet0915.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://jasmeet0915.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Programming a Non-Programmable ESP8266 Board"><meta property="og:description" content="If you are like me, you want RGB lights in everything. Be it your mouse, your keyboard, or heck even your room. Therefore, to fulfill this colorful need, I started working on a project to install the addressable WS2812B LEDs to the shelves in my room. The plan was simple: use an ESP8266-based board (specifically the Wemos D1 Mini) with WLED installed as the main controller, hook it up the LEDs and use the WLED Android App to control the LEDs."><meta property="og:type" content="article"><meta property="og:url" content="https://jasmeet0915.github.io/posts/bolt_iot_programming/"><meta property="og:image" content="https://jasmeet0915.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="og:site_name" content="Jasmeet Singh"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jasmeet0915.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Programming a Non-Programmable ESP8266 Board"><meta name=twitter:description content="If you are like me, you want RGB lights in everything. Be it your mouse, your keyboard, or heck even your room. Therefore, to fulfill this colorful need, I started working on a project to install the addressable WS2812B LEDs to the shelves in my room. The plan was simple: use an ESP8266-based board (specifically the Wemos D1 Mini) with WLED installed as the main controller, hook it up the LEDs and use the WLED Android App to control the LEDs."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://jasmeet0915.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Programming a Non-Programmable ESP8266 Board","item":"https://jasmeet0915.github.io/posts/bolt_iot_programming/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Programming a Non-Programmable ESP8266 Board","name":"Programming a Non-Programmable ESP8266 Board","description":"If you are like me, you want RGB lights in everything. Be it your mouse, your keyboard, or heck even your room. Therefore, to fulfill this colorful need, I started working on a project to install the addressable WS2812B LEDs to the shelves in my room. The plan was simple: use an ESP8266-based board (specifically the Wemos D1 Mini) with WLED installed as the main controller, hook it up the LEDs and use the WLED Android App to control the LEDs.","keywords":["ESP8266","IOT","Boot Modes","Programming","Bolt IOT"],"articleBody":"If you are like me, you want RGB lights in everything. Be it your mouse, your keyboard, or heck even your room. Therefore, to fulfill this colorful need, I started working on a project to install the addressable WS2812B LEDs to the shelves in my room. The plan was simple: use an ESP8266-based board (specifically the Wemos D1 Mini) with WLED installed as the main controller, hook it up the LEDs and use the WLED Android App to control the LEDs.\nSo as with any project, I hopped on the metro, arrived at the local market and bought all the required stuff including the LED Strip, Wemos D1 Mini board, an IRF540N n-channel MOSFET, some JST Connectors and screw terminals etc.\nIf you are interested in making the project yourself, you can go through and follow the steps in my Instructable.\nAnyways, back to the story. So, after getting all the stuff I returned home, connected the Wemos D1 Mini to my laptop, selected the correct port in Arduino IDE and uploaded the blink LED sketch to test the board. Aaaaand it didn‚Äôt work :(\nUpon close inspection, I found some weird stuff going on with the board!! And with that came a realization‚Ä¶\nNever Blindly Trust the Stuff You Buy So here‚Äôs the problem: Whenever the board is connected, a serial port shows up in the Arduino IDE but no matter what, you cannot upload any code to it. Even dmesg shows that it is loading a driver for the FT232RL USB-to-UART Chip!\ndmesg output when the Wemos D1 Mini board was connected. It shows that the Kernel is loading the drivers for the FT232RL USB-to-UART\nEven the windows device manager does the same: assigns FT232 drivers for the device but the result is still the same. We can see the idVendor in the dmesg output as 0403 and a quick google search shows that this Vendor ID indeed belongs to FTDI (this is the company that manufactures the FT232RL chip). But here‚Äôs the catch:\nIf you read the Official Wemos Documentation for the D1 mini, it shows that the board uses CH340 as the USB-to-UART Converter not the FT232R! üòµ‚Äçüí´\nSooooo, what the hell is happening here?\nTo find some answers I turned to the board specifically to see if it was actually using the FT232. And guess what? The name of the IC is erased off‚Ä¶ü•≤ Believe me when I say this does not end here. It gets better.\nThe Wemos D1 Mini board backside that shows the USB-to-UART chip with no name\nI opened up the pinout of FT232R and the CH340 side by side, powered the board and started probing some pins with my multimeter to see which pinout it matches. Aaanddd‚Ä¶drum rolls please‚Ä¶it matches the pinout of the CH340 IC!! So, it is indeed CH340 but it acts like FT232R causing the OS to load the wrong drivers and resulting in the board not working.\nSo people, that‚Äôs why you should never completely trust the stuff you buy locally. As for me, I kept the board aside for further investigations and turned to next closest thing to an ESP-based board I had at the ready. This turned out to be the Bolt IOT Wifi Module which I had bought about 3 years back but never used once.\nThe Bolt IOT wifi module\nIf I had this, then why didn‚Äôt I go with it in the first place? Well, because although the WEMOS D1 Mini and Bolt IOT wifi module both use the same ESP-12E at its core, there is a big difference. While the Wemos D1 Mini is a developement board and can be programmed through USB for any application, the Bolt IOT Wifi Module is, in fact, a module. It comes pre-flashed with some code that allows you to program it through the Bolt IOT cloud platform (or app) or you can hook it up to an Arduino as a wifi module. The module itself does not have any USB-to-UART Converter on board. In my opinion, this feels kind of a waste of capability of the ESP-12E module as it prevents standalone use of the board which I wanted in my case. So, let‚Äôs see how I worked my way around this.\nThe ESP-12E Bootloader Modes \u0026 How it gets Programmed To understand how I used the Bolt IOT Wifi Module for this, we first need to understand the bootloader modes of the ESP-12E module. When we power up the ESP-12E module, there are 3 different modes the moduel can enter:\nNormal Mode UART Programming Mode SD-Card Boot Here we only care about the Normal Mode and the UART Programming Mode. Normal Mode or the Flash Start-up Mode, as the name suggests, loads the program saved in the module‚Äôs internal flash and starts executing it. This is mode we are most familiar with. The UART Programming Mode is the one which allows you to upload a new program to the module‚Äôs flash memory through UART. The bootloader which gets selected when the device powers up or is reset, depends on the state of some of the GPIOs. Below you can find a table that shows the required GPIO states for different bootloader modes.\nBootloader Mode GPIO 0 GPIO 2 GPIO 15 Normal Mode 1 1 0 UART Programming Mode 0 1 0 SD Card Boot 0 0 1 From the table above, we can easily infer that the state of GPIO 0 is the main deciding factor for our desired bootloader modes as the other two GPIOs have the same state in both cases. Apart from this, if the RESET pin gets connected to GND, the board resets and again selects the bootloader mode accroding to the states of the above GPIOs. Below you can find a pinout diagram of ESP-12E for reference.\nESP-12E module pinout. Credits: Random Nerd Tutorials\nSo basically this is what we need to do to make the ESP-12E on the Bolt IOT Module Programmable:\nPull GPIO 2 up Pull GPIO 15 down Have some sort of mechanism to change the state of GPIO 0 as required Have a push button connected to the RESET pin that connects it GND when pressed Upon inspecting the ESP12-E on the Bolt IOT Module these are the things I found:\nRESET Pin was left floating GPIO2 was left floating GPIO15 was connected to the GND Plane GPIO0 was left floating. Since the board already had a program flashed for OTA (over the air) uploads they don‚Äôt need the GPIO0 Making the ESP12-E on the Bolt IOT Module Programmable So from the above points I knew I had to only:\nConnect GPIO2 to VCC through a pull up resistor Connect a push button to RESET that connects it to GND when pressed. We can name this the ‚ÄòReset‚Äô button. Connect a GPIO0 to a push button that connects it to GND when pressed. We can name this the ‚ÄòBoot‚Äô button. Have a 6 Pin female header that exposes the TX, RX and GND pins for connecting an external USB-to-UART Converter Module to program the module Here‚Äôs a schematic of how this was done:\nA schematic of the setup I made. It does not show the connections of the Bolt IOT module like the voltage regulator, on-board LEDs, etc.\nOnce this is done, to program the mode we can simply press the Boot button and then reset the board using the Reset button. This will send the board in the Programming Mode and then we can hook up the external USB-to-UART module and upload a program to the board!\nNote: You might have seen the same two buttons (Reset and Boot) on some ESP-based boards like the NodeMCU or ESP32. These work on the same principle.\nNote: You also might have noticed that you don‚Äôt have to do play with these buttons everytime on a board like the NodeMCU. Heck the Arduino UNO does not even have a Boot button. So, how are they changing the bootloader modes? This is where the USB-to-UART IC comes in. It automatically sends some signals to the required pins and changes the bootloader modes when you press the upload button on your Arduino IDE.\nHere are some photos of the final soldered setup on a perf board for the final project:\nThe Bolt IOT wifi module with the wires soldered on required GPIOs\nAbove schematic on soldered on a perf board\nAnd here are some images of the final project: ","wordCount":"1412","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jasmeet0915.github.io/posts/bolt_iot_programming/"},"publisher":{"@type":"Organization","name":"Jasmeet Singh","logo":{"@type":"ImageObject","url":"https://jasmeet0915.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jasmeet0915.github.io accesskey=h title="Home (Alt + H)"><img src=https://jasmeet0915.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jasmeet0915.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://jasmeet0915.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://atom-robotics-lab.github.io/ title="A.T.O.M Robotics Lab"><span>A.T.O.M Robotics Lab</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jasmeet0915.github.io>Home</a>&nbsp;¬ª&nbsp;<a href=https://jasmeet0915.github.io/posts/>Posts</a></div><h1 class=post-title>Programming a Non-Programmable ESP8266 Board</h1><div class=post-meta>7 min&nbsp;¬∑&nbsp;1412 words&nbsp;¬∑&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/bolt_iot_programming.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents></nav></div></details></div><div class=post-content><p>If you are like me, you want RGB lights in everything. Be it your mouse, your keyboard, or heck even your room. Therefore, to fulfill this <em>colorful</em> need, I started working on a project to install the addressable WS2812B LEDs to the shelves in my room. The plan was simple: use an ESP8266-based board (specifically the Wemos D1 Mini) with <a href=https://kno.wled.ge/>WLED</a> installed as the main controller, hook it up the LEDs and use the WLED Android App to control the LEDs.</p><p>So as with any project, I hopped on the metro, arrived at the local market and bought all the required stuff including the LED Strip, Wemos D1 Mini board, an IRF540N n-channel MOSFET, some JST Connectors and screw terminals etc.</p><blockquote><p>If you are interested in making the project yourself, you can go through and follow the steps in my <a href>Instructable</a>.</p></blockquote><p>Anyways, back to the story. So, after getting all the stuff I returned home, connected the Wemos D1 Mini to my laptop, selected the correct port in Arduino IDE and uploaded the blink LED sketch to test the board. Aaaaand it didn&rsquo;t work :(</p><p>Upon close inspection, I found some weird stuff going on with the board!! And with that came a realization&mldr;</p><h1 id=never-blindly-trust-the-stuff-you-buy>Never Blindly Trust the Stuff You Buy<a hidden class=anchor aria-hidden=true href=#never-blindly-trust-the-stuff-you-buy>#</a></h1><p>So here&rsquo;s the problem: Whenever the board is connected, a serial port shows up in the Arduino IDE but no matter what, you cannot upload any code to it. Even <code>dmesg</code> shows that it is loading a driver for the FT232RL USB-to-UART Chip!</p><figure class=align-center><img loading=lazy src=/images/blogs/bolt_iot/wemos_dmesg_output.png#center alt="dmesg output when the Wemos D1 Mini board was connected. It shows that the Kernel is loading the drivers for the FT232RL USB-to-UART"><figcaption><p>dmesg output when the Wemos D1 Mini board was connected. It shows that the Kernel is loading the drivers for the FT232RL USB-to-UART</p></figcaption></figure><p>Even the windows device manager does the same: assigns FT232 drivers for the device but the result is still the same. We can see the <code>idVendor</code> in the dmesg output as <code>0403</code> and a quick google search shows that this Vendor ID indeed belongs to FTDI (this is the company that manufactures the FT232RL chip). <em>But here&rsquo;s the catch:</em></p><p>If you read the <a href=https://www.wemos.cc/en/latest/d1/index.html>Official Wemos Documentation for the D1 mini</a>, it shows that the board uses <a href=https://cdn.sparkfun.com/datasheets/Dev/Arduino/Other/CH340DS1.PDF>CH340</a> as the USB-to-UART Converter not the FT232R! üòµ‚Äçüí´</p><p><strong>Sooooo, what the hell is happening here?</strong></p><p>To find some answers I turned to the board specifically to see if it was actually using the FT232. And guess what? The name of the IC is erased off&mldr;ü•≤ Believe me when I say this does not end here. It gets better.</p><figure class=align-center><img loading=lazy src=/images/blogs/bolt_iot/wemos_no_name.png#center alt="The Wemos D1 Mini board backside that shows the USB-to-UART chip with no name" width=400><figcaption><p>The Wemos D1 Mini board backside that shows the USB-to-UART chip with no name</p></figcaption></figure><p>I opened up the pinout of FT232R and the CH340 side by side, powered the board and started probing some pins with my multimeter to see which pinout it matches. Aaanddd&mldr;<em>drum rolls please</em>&mldr;it matches the pinout of the CH340 IC!! So, it is indeed CH340 but it acts like FT232R causing the OS to load the wrong drivers and resulting in the board not working.</p><figure class=align-center><img loading=lazy src=/images/blogs/bolt_iot/blow-mind.gif#center></figure><p>So people, that&rsquo;s why you should never completely trust the stuff you buy locally. As for me, I kept the board aside for further investigations and turned to next closest thing to an ESP-based board I had at the ready. This turned out to be the <a href=https://docs.boltiot.com/docs/bolt-wifi-module>Bolt IOT Wifi Module</a> which I had bought about 3 years back but never used once.</p><figure class=align-center><img loading=lazy src=/images/blogs/bolt_iot/bolt_iot_1.jpg#center alt="The Bolt IOT wifi module" width=600><figcaption><p>The Bolt IOT wifi module</p></figcaption></figure><p>If I had this, then why didn&rsquo;t I go with it in the first place? Well, because although the WEMOS D1 Mini and Bolt IOT wifi module both use the same <a href=https://components101.com/sites/default/files/2021-09/ESP12E-Datasheet.pdf>ESP-12E</a> at its core, there is a big difference. While the Wemos D1 Mini is a developement board and can be programmed through USB for any application, the Bolt IOT Wifi Module is, in fact, a module. It comes pre-flashed with some code that allows you to program it through the Bolt IOT cloud platform (or app) or you can hook it up to an Arduino as a wifi module. The module itself does not have any USB-to-UART Converter on board. In my opinion, this feels kind of a waste of capability of the ESP-12E module as it prevents standalone use of the board which I wanted in my case. So, let&rsquo;s see how I worked my way around this.</p><h1 id=the-esp-12e-bootloader-modes--how-it-gets-programmed>The ESP-12E Bootloader Modes & How it gets Programmed<a hidden class=anchor aria-hidden=true href=#the-esp-12e-bootloader-modes--how-it-gets-programmed>#</a></h1><p>To understand how I used the Bolt IOT Wifi Module for this, we first need to understand the bootloader modes of the ESP-12E module. When we power up the ESP-12E module, there are 3 different modes the moduel can enter:</p><ul><li>Normal Mode</li><li>UART Programming Mode</li><li>SD-Card Boot</li></ul><p>Here we only care about the <strong>Normal Mode</strong> and the <strong>UART Programming Mode</strong>. Normal Mode or the Flash Start-up Mode, as the name suggests, loads the program saved in the module&rsquo;s internal flash and starts executing it. This is mode we are most familiar with. The UART Programming Mode is the one which allows you to upload a new program to the module&rsquo;s flash memory through UART. The bootloader which gets selected when the device powers up or is reset, depends on the state of some of the GPIOs. Below you can find a table that shows the required GPIO states for different bootloader modes.</p><table><thead><tr><th>Bootloader Mode</th><th>GPIO 0</th><th>GPIO 2</th><th>GPIO 15</th><th></th></tr></thead><tbody><tr><td>Normal Mode</td><td>1</td><td>1</td><td>0</td><td></td></tr><tr><td>UART Programming Mode</td><td>0</td><td>1</td><td>0</td><td></td></tr><tr><td>SD Card Boot</td><td>0</td><td>0</td><td>1</td><td></td></tr></tbody></table><p>From the table above, we can easily infer that the state of <em>GPIO 0</em> is the main deciding factor for our desired bootloader modes as the other two GPIOs have the same state in both cases. Apart from this, if the <code>RESET</code> pin gets connected to <code>GND</code>, the board resets and again selects the bootloader mode accroding to the states of the above GPIOs. Below you can find a pinout diagram of ESP-12E for reference.</p><figure class=align-center><img loading=lazy src=/images/blogs/bolt_iot/esp12e_pinout.jpg#center alt="ESP-12E module pinout. Credits: Random Nerd Tutorials"><figcaption><p>ESP-12E module pinout. Credits: Random Nerd Tutorials</p></figcaption></figure><p>So basically this is what we need to do to make the ESP-12E on the Bolt IOT Module Programmable:</p><ul><li>Pull <code>GPIO 2</code> up</li><li>Pull <code>GPIO 15</code> down</li><li>Have some sort of mechanism to change the state of <code>GPIO 0</code> as required</li><li>Have a push button connected to the <code>RESET</code> pin that connects it <code>GND</code> when pressed</li></ul><p>Upon inspecting the ESP12-E on the Bolt IOT Module these are the things I found:</p><ul><li><code>RESET</code> Pin was left floating</li><li><code>GPIO2</code> was left floating</li><li><code>GPIO15</code> was connected to the GND Plane</li><li><code>GPIO0</code> was left floating. Since the board already had a program flashed for OTA (over the air) uploads they don&rsquo;t need the GPIO0</li></ul><h1 id=making-the-esp12-e-on-the-bolt-iot-module-programmable>Making the ESP12-E on the Bolt IOT Module Programmable<a hidden class=anchor aria-hidden=true href=#making-the-esp12-e-on-the-bolt-iot-module-programmable>#</a></h1><p>So from the above points I knew I had to only:</p><ul><li>Connect <code>GPIO2</code> to VCC through a pull up resistor</li><li>Connect a push button to <code>RESET</code> that connects it to <code>GND</code> when pressed. We can name this the &lsquo;Reset&rsquo; button.</li><li>Connect a <code>GPIO0</code> to a push button that connects it to <code>GND</code> when pressed. We can name this the &lsquo;Boot&rsquo; button.</li><li>Have a 6 Pin female header that exposes the <code>TX</code>, <code>RX</code> and <code>GND</code> pins for connecting an external USB-to-UART Converter Module to program the module</li></ul><p>Here&rsquo;s a schematic of how this was done:</p><figure class=align-center><img loading=lazy src=/images/blogs/bolt_iot/schematic.png#center alt="A schematic of the setup I made. It does not show the connections of the Bolt IOT module like the voltage regulator, on-board LEDs, etc."><figcaption><p>A schematic of the setup I made. It does not show the connections of the Bolt IOT module like the voltage regulator, on-board LEDs, etc.</p></figcaption></figure><p>Once this is done, to program the mode we can simply press the <code>Boot</code> button and then reset the board using the <code>Reset</code> button. This will send the board in the Programming Mode and then we can hook up the external USB-to-UART module and upload a program to the board!</p><blockquote><p><strong>Note:</strong> You might have seen the same two buttons (Reset and Boot) on some ESP-based boards like the NodeMCU or ESP32. These work on the same principle.</p></blockquote><blockquote><p><strong>Note:</strong> You also might have noticed that you don&rsquo;t have to do play with these buttons everytime on a board like the NodeMCU. Heck the Arduino UNO does not even have a <code>Boot</code> button. So, how are they changing the bootloader modes? This is where the USB-to-UART IC comes in. It automatically sends some signals to the required pins and changes the bootloader modes when you press the upload button on your Arduino IDE.</p></blockquote><p>Here are some photos of the final soldered setup on a perf board for the final project:</p><p><figure class=align-center><img loading=lazy src=/images/blogs/bolt_iot/module_wires_soldered.jpg#center alt="The Bolt IOT wifi module with the wires soldered on required GPIOs" width=600><figcaption><p>The Bolt IOT wifi module with the wires soldered on required GPIOs</p></figcaption></figure><figure class=align-center><img loading=lazy src=/images/blogs/bolt_iot/perf_board_without_module.jpg#center width=600></figure><figure class=align-center><img loading=lazy src=/images/blogs/bolt_iot/perf_board_with_module.jpg#center alt="Above schematic on soldered on a perf board" width=600><figcaption><p>Above schematic on soldered on a perf board</p></figcaption></figure></p><p>And here are some images of the final project:<figure class=align-center><img loading=lazy src=/images/blogs/bolt_iot/cover-3.jpg#center width=600></figure><figure class=align-center><img loading=lazy src=/images/blogs/bolt_iot/box.jpg#center width=600></figure></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://jasmeet0915.github.io/tags/esp8266/>ESP8266</a></li><li><a href=https://jasmeet0915.github.io/tags/iot/>IOT</a></li><li><a href=https://jasmeet0915.github.io/tags/boot-modes/>Boot Modes</a></li><li><a href=https://jasmeet0915.github.io/tags/programming/>Programming</a></li><li><a href=https://jasmeet0915.github.io/tags/bolt-iot/>Bolt IOT</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Programming a Non-Programmable ESP8266 Board on twitter" href="https://twitter.com/intent/tweet/?text=Programming%20a%20Non-Programmable%20ESP8266%20Board&url=https%3a%2f%2fjasmeet0915.github.io%2fposts%2fbolt_iot_programming%2f&hashtags=ESP8266%2cIOT%2cBootModes%2cProgramming%2cBoltIOT"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Programming a Non-Programmable ESP8266 Board on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjasmeet0915.github.io%2fposts%2fbolt_iot_programming%2f&title=Programming%20a%20Non-Programmable%20ESP8266%20Board&summary=Programming%20a%20Non-Programmable%20ESP8266%20Board&source=https%3a%2f%2fjasmeet0915.github.io%2fposts%2fbolt_iot_programming%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Programming a Non-Programmable ESP8266 Board on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjasmeet0915.github.io%2fposts%2fbolt_iot_programming%2f&title=Programming%20a%20Non-Programmable%20ESP8266%20Board"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Programming a Non-Programmable ESP8266 Board on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjasmeet0915.github.io%2fposts%2fbolt_iot_programming%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Programming a Non-Programmable ESP8266 Board on whatsapp" href="https://api.whatsapp.com/send?text=Programming%20a%20Non-Programmable%20ESP8266%20Board%20-%20https%3a%2f%2fjasmeet0915.github.io%2fposts%2fbolt_iot_programming%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Programming a Non-Programmable ESP8266 Board on telegram" href="https://telegram.me/share/url?text=Programming%20a%20Non-Programmable%20ESP8266%20Board&url=https%3a%2f%2fjasmeet0915.github.io%2fposts%2fbolt_iot_programming%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://jasmeet0915.github.io>Jasmeet Singh</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>